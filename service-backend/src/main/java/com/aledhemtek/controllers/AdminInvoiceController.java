package com.aledhemtek.controllers;

import com.aledhemtek.model.Invoice;
import com.aledhemtek.model.InvoiceItem;
import com.aledhemtek.model.Reservation;
import com.aledhemtek.repositories.InvoiceRepository;
import com.aledhemtek.repositories.ReservationRepository;
import com.aledhemtek.services.InvoicePDFService;
import com.aledhemtek.services.EmailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.*;

/**
 * Clean and simple admin invoice controller
 * Handles all admin invoice management operations
 */
@RestController
@RequestMapping("/api/admin/invoices")
@CrossOrigin(origins = "*")
@PreAuthorize("hasRole('ADMIN')")
public class AdminInvoiceController {

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private ReservationRepository reservationRepository;

    @Autowired
    private InvoicePDFService invoicePDFService;

    @Autowired
    private EmailService emailService;

    /**
     * Get all invoices with pagination and filtering
     */
    @GetMapping
    public ResponseEntity<Map<String, Object>> getAllInvoices(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "issueDate") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String search) {

        try {
            Sort sort = sortDir.equalsIgnoreCase("desc") 
                ? Sort.by(sortBy).descending() 
                : Sort.by(sortBy).ascending();
            
            Pageable pageable = PageRequest.of(page, size, sort);
            Page<Invoice> invoicesPage;

            // Filter by status if provided
            if (status != null && !status.isEmpty()) {
                Invoice.InvoiceStatus invoiceStatus = Invoice.InvoiceStatus.valueOf(status.toUpperCase());
                invoicesPage = invoiceRepository.findByStatus(invoiceStatus, pageable);
            } else {
                invoicesPage = invoiceRepository.findAll(pageable);
            }

            // Convert to DTOs for frontend
            List<Map<String, Object>> invoiceDTOs = new ArrayList<>();
            for (Invoice invoice : invoicesPage.getContent()) {
                Map<String, Object> dto = new HashMap<>();
                dto.put("id", invoice.getId());
                dto.put("invoiceNumber", invoice.getInvoiceNumber());
                dto.put("issueDate", invoice.getIssueDate());
                dto.put("dueDate", invoice.getDueDate());
                dto.put("totalAmount", invoice.getTotalAmount());
                dto.put("status", invoice.getStatus());
                dto.put("emailSent", invoice.getEmailSent());
                dto.put("autoGenerated", invoice.getAutoGenerated());
                
                // Add client information
                if (invoice.getReservation() != null && invoice.getReservation().getClient() != null) {
                    dto.put("clientName", invoice.getReservation().getClient().getFirstName() + " " + 
                                         invoice.getReservation().getClient().getLastName());
                    dto.put("clientEmail", invoice.getReservation().getClient().getEmail());
                    dto.put("reservationId", invoice.getReservation().getId());
                } else {
                    dto.put("clientName", "Client non défini");
                    dto.put("clientEmail", "");
                    dto.put("reservationId", null);
                }

                // Add invoice items count
                dto.put("itemsCount", invoice.getInvoiceItems().size());
                
                // Add remaining amount
                dto.put("remainingAmount", invoice.getRemainingAmount());
                
                invoiceDTOs.add(dto);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("content", invoiceDTOs);
            response.put("totalElements", invoicesPage.getTotalElements());
            response.put("totalPages", invoicesPage.getTotalPages());
            response.put("currentPage", page);
            response.put("size", size);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("Error fetching invoices: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors du chargement des factures: " + e.getMessage()));
        }
    }

    /**
     * Get invoice by ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<Map<String, Object>> getInvoiceById(@PathVariable Long id) {
        try {
            Optional<Invoice> invoiceOpt = invoiceRepository.findWithDetailsById(id);
            if (invoiceOpt.isEmpty()) {
                return ResponseEntity.notFound().build();
            }

            Invoice invoice = invoiceOpt.get();
            
            // Debug logs
            System.out.println("[DEBUG] Invoice ID: " + invoice.getId());
            System.out.println("[DEBUG] Invoice Number: " + invoice.getInvoiceNumber());
            System.out.println("[DEBUG] Invoice Items count: " + (invoice.getInvoiceItems() != null ? invoice.getInvoiceItems().size() : "null"));
            if (invoice.getInvoiceItems() != null) {
                for (int i = 0; i < invoice.getInvoiceItems().size(); i++) {
                    var item = invoice.getInvoiceItems().get(i);
                    System.out.println("[DEBUG] Item " + i + ": " + item.getDescription() + ", Qty: " + item.getQuantity() + ", Price: " + item.getUnitPrice());
                }
            }
            
            Map<String, Object> dto = createInvoiceDetailDTO(invoice);
            
            return ResponseEntity.ok(dto);

        } catch (Exception e) {
            System.err.println("Error fetching invoice " + id + ": " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors du chargement de la facture"));
        }
    }

    /**
     * Update invoice status
     */
    @PutMapping("/{id}/status")
    public ResponseEntity<Map<String, Object>> updateInvoiceStatus(
            @PathVariable Long id, 
            @RequestBody Map<String, String> request) {
        
        try {
            Optional<Invoice> invoiceOpt = invoiceRepository.findById(id);
            if (invoiceOpt.isEmpty()) {
                return ResponseEntity.notFound().build();
            }

            Invoice invoice = invoiceOpt.get();
            String newStatus = request.get("status");
            
            if (newStatus != null) {
                invoice.setStatus(Invoice.InvoiceStatus.valueOf(newStatus.toUpperCase()));
                invoice.setUpdatedAt(LocalDateTime.now());
                
                // If marking as sent, update email sent date
                if (newStatus.equalsIgnoreCase("SENT")) {
                    invoice.setEmailSent(true);
                    invoice.setEmailSentDate(LocalDateTime.now());
                }
                
                invoiceRepository.save(invoice);
            }

            return ResponseEntity.ok(Map.of(
                "message", "Statut de la facture mis à jour avec succès",
                "status", invoice.getStatus()
            ));

        } catch (Exception e) {
            System.err.println("Error updating invoice status: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors de la mise à jour du statut"));
        }
    }

    /**
     * Generate and download PDF for invoice
     */
    @GetMapping("/{id}/pdf")
    public ResponseEntity<byte[]> downloadInvoicePDF(@PathVariable Long id) {
        try {
            Optional<Invoice> invoiceOpt = invoiceRepository.findById(id);
            if (invoiceOpt.isEmpty()) {
                return ResponseEntity.notFound().build();
            }

            Invoice invoice = invoiceOpt.get();
            byte[] pdfBytes = invoicePDFService.generateInvoicePDFBytes(invoice);
        
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PDF);
            headers.setContentDispositionFormData("attachment", 
                "facture_" + invoice.getInvoiceNumber() + ".pdf");
        
            return ResponseEntity.ok()
                .headers(headers)
                .body(pdfBytes);

        } catch (Exception e) {
            System.err.println("Error generating PDF for invoice " + id + ": " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Send invoice by email
     */
    @PostMapping("/{id}/send-email")
    public ResponseEntity<Map<String, Object>> sendInvoiceByEmail(@PathVariable Long id) {
        try {
            Optional<Invoice> invoiceOpt = invoiceRepository.findById(id);
            if (invoiceOpt.isEmpty()) {
                return ResponseEntity.notFound().build();
            }

            Invoice invoice = invoiceOpt.get();
            
            // Check if we have client email
            if (invoice.getReservation() == null || 
                invoice.getReservation().getClient() == null || 
                invoice.getReservation().getClient().getEmail() == null) {
                return ResponseEntity.badRequest()
                    .body(Map.of("error", "Aucun email client disponible pour cette facture"));
            }

            // Generate PDF first, then send email
            String clientEmail = invoice.getReservation().getClient().getEmail();
            try {
                // Generate PDF as byte array
                byte[] pdfBytes = invoicePDFService.generateInvoicePDFBytes(invoice);
                
                // Send email with PDF attachment
                emailService.sendInvoiceEmail(invoice, pdfBytes);
                System.out.println("Invoice " + invoice.getInvoiceNumber() + " sent successfully to " + clientEmail);
            } catch (Exception emailError) {
                System.err.println("Failed to send email: " + emailError.getMessage());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Erreur lors de l'envoi de l'email: " + emailError.getMessage()));
            }
            
            // Update invoice
            invoice.setEmailSent(true);
            invoice.setEmailSentDate(LocalDateTime.now());
            invoice.setStatus(Invoice.InvoiceStatus.SENT);
            invoiceRepository.save(invoice);

            return ResponseEntity.ok(Map.of(
                "message", "Facture envoyée par email avec succès",
                "email", clientEmail
            ));

        } catch (Exception e) {
            System.err.println("Error sending invoice email: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors de l'envoi de l'email"));
        }
    }

    /**
     * Create invoice from reservation
     */
    @PostMapping("/create-from-reservation/{reservationId}")
    public ResponseEntity<Map<String, Object>> createInvoiceFromReservation(@PathVariable Long reservationId) {
        try {
            Optional<Reservation> reservationOpt = reservationRepository.findById(reservationId);
            if (reservationOpt.isEmpty()) {
                return ResponseEntity.badRequest()
                    .body(Map.of("error", "Réservation non trouvée"));
            }

            Reservation reservation = reservationOpt.get();
            
            // Check if invoice already exists
            List<Invoice> existingInvoices = invoiceRepository.findByReservation_Id(reservationId);
            if (!existingInvoices.isEmpty()) {
                return ResponseEntity.badRequest()
                    .body(Map.of("error", "Une facture existe déjà pour cette réservation"));
            }

            // Create new invoice
            Invoice invoice = new Invoice(reservation);
            invoice.setAutoGenerated(false); // Manual creation by admin
            
            // Add invoice items from reservation tasks
            if (reservation.getReservationTasks() != null) {
                for (var reservationTask : reservation.getReservationTasks()) {
                    InvoiceItem item = new InvoiceItem();
                    item.setInvoice(invoice);
                    item.setDesignation(reservationTask.getTask().getName());
                    item.setDescription(reservationTask.getTask().getDescription());
                    item.setQuantity(reservationTask.getQuantity());
                    item.setUnitPrice(reservationTask.getUnitPrice());
                    item.setTotal(reservationTask.getTotalPrice());
                    item.setTaxRate(20.0); // Default tax rate
                    
                    invoice.getInvoiceItems().add(item);
                }
            }

            // Calculate amounts
            invoice.calculateAmounts();
            
            // Save invoice (this will generate ID)
            invoice = invoiceRepository.save(invoice);
            
            // Generate invoice number after save
            invoice.generateInvoiceNumber();
            invoice = invoiceRepository.save(invoice);

            return ResponseEntity.ok(Map.of(
                "message", "Facture créée avec succès",
                "invoiceId", invoice.getId(),
                "invoiceNumber", invoice.getInvoiceNumber()
            ));

        } catch (Exception e) {
            System.err.println("Error creating invoice from reservation: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors de la création de la facture: " + e.getMessage()));
        }
    }

    /**
     * Get dashboard statistics
     */
    @GetMapping("/stats")
    public ResponseEntity<Map<String, Object>> getInvoiceStats() {
        try {
            Map<String, Object> stats = new HashMap<>();
            
            // Total invoices
            long totalInvoices = invoiceRepository.count();
            stats.put("totalInvoices", totalInvoices);
            
            // Invoices by status
            for (Invoice.InvoiceStatus status : Invoice.InvoiceStatus.values()) {
                long count = invoiceRepository.findByStatus(status).size();
                stats.put(status.name().toLowerCase() + "Count", count);
            }
            
            // Total amount
            List<Invoice> allInvoices = invoiceRepository.findAll();
            double totalAmount = allInvoices.stream()
                .mapToDouble(Invoice::getTotalAmount)
                .sum();
            stats.put("totalAmount", totalAmount);
            
            // Paid amount
            double paidAmount = allInvoices.stream()
                .filter(i -> i.getStatus() == Invoice.InvoiceStatus.PAID)
                .mapToDouble(Invoice::getTotalAmount)
                .sum();
            stats.put("paidAmount", paidAmount);
            
            // Pending amount
            double pendingAmount = totalAmount - paidAmount;
            stats.put("pendingAmount", pendingAmount);

            return ResponseEntity.ok(stats);

        } catch (Exception e) {
            System.err.println("Error fetching invoice stats: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Erreur lors du chargement des statistiques"));
        }
    }

    /**
     * Helper method to create detailed invoice DTO
     */
    private Map<String, Object> createInvoiceDetailDTO(Invoice invoice) {
        Map<String, Object> dto = new HashMap<>();
        
        dto.put("id", invoice.getId());
        dto.put("invoiceNumber", invoice.getInvoiceNumber());
        dto.put("issueDate", invoice.getIssueDate());
        dto.put("dueDate", invoice.getDueDate());
        dto.put("totalAmount", invoice.getTotalAmount());
        dto.put("amountExclTax", invoice.getAmountExclTax());
        dto.put("taxAmount", invoice.getTaxAmount());
        dto.put("taxRate", invoice.getTaxRate());
        dto.put("status", invoice.getStatus());
        dto.put("notes", invoice.getNotes());
        dto.put("emailSent", invoice.getEmailSent());
        dto.put("emailSentDate", invoice.getEmailSentDate());
        dto.put("autoGenerated", invoice.getAutoGenerated());
        dto.put("createdAt", invoice.getCreatedAt());
        dto.put("updatedAt", invoice.getUpdatedAt());
        
        // Client information
        if (invoice.getReservation() != null && invoice.getReservation().getClient() != null) {
            Map<String, Object> client = new HashMap<>();
            client.put("name", invoice.getReservation().getClient().getFirstName() + " " + 
                              invoice.getReservation().getClient().getLastName());
            client.put("email", invoice.getReservation().getClient().getEmail());
            client.put("phone", invoice.getReservation().getClient().getPhone());
            dto.put("client", client);
            dto.put("reservationId", invoice.getReservation().getId());
        }
        
        // Invoice items
        List<Map<String, Object>> items = new ArrayList<>();
        System.out.println("[DEBUG] Creating DTO - Invoice items count: " + (invoice.getInvoiceItems() != null ? invoice.getInvoiceItems().size() : "null"));
        
        if (invoice.getInvoiceItems() != null) {
            for (InvoiceItem item : invoice.getInvoiceItems()) {
                Map<String, Object> itemDto = new HashMap<>();
                itemDto.put("id", item.getId());
                itemDto.put("designation", item.getDesignation());
                itemDto.put("description", item.getDescription());
                itemDto.put("quantity", item.getQuantity());
                itemDto.put("unitPrice", item.getUnitPrice());
                itemDto.put("totalPrice", item.getTotal());
                itemDto.put("taxRate", item.getTaxRate());
                items.add(itemDto);
                System.out.println("[DEBUG] Added item to DTO: " + item.getDescription());
            }
        }
        dto.put("items", items);
        System.out.println("[DEBUG] Final items list size: " + items.size());
        
        // Payments
        List<Map<String, Object>> payments = new ArrayList<>();
        for (var payment : invoice.getPayments()) {
            Map<String, Object> paymentDto = new HashMap<>();
            paymentDto.put("id", payment.getId());
            paymentDto.put("amount", payment.getAmount());
            paymentDto.put("paymentMethod", payment.getPaymentMethod());
            paymentDto.put("status", payment.getStatus());
            paymentDto.put("paymentDate", payment.getPaymentDate());
            payments.add(paymentDto);
        }
        dto.put("payments", payments);
        
        // Remaining amount
        dto.put("remainingAmount", invoice.getRemainingAmount());
        
        return dto;
    }
}
